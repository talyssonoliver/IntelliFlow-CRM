/**
 * Artifact Actions API
 *
 * POST /api/artifacts/actions - Execute cleanup actions
 *
 * Actions:
 * - delete: Remove file permanently
 * - archive: Move to artifacts/archive/
 * - ignore: Add to .artifactignore (won't show as orphan)
 */

import { NextRequest, NextResponse } from 'next/server';
import { existsSync, mkdirSync, renameSync, unlinkSync, appendFileSync, readFileSync } from 'fs';
import { join, dirname, basename } from 'path';

const PROJECT_ROOT = process.cwd().replace(/[\\/]apps[\\/]project-tracker$/, '');
const ARCHIVE_DIR = join(PROJECT_ROOT, 'artifacts', 'archive');
const IGNORE_FILE = join(PROJECT_ROOT, '.artifactignore');

interface ActionRequest {
  action: 'delete' | 'archive' | 'ignore';
  paths: string[];
}

interface ActionResult {
  path: string;
  success: boolean;
  error?: string;
  newPath?: string;
}

/**
 * Load existing ignore patterns
 */
function loadIgnorePatterns(): Set<string> {
  if (!existsSync(IGNORE_FILE)) {
    return new Set();
  }
  const content = readFileSync(IGNORE_FILE, 'utf-8');
  return new Set(
    content
      .split('\n')
      .map((line) => line.trim())
      .filter((line) => line && !line.startsWith('#'))
  );
}

/**
 * Add paths to ignore file
 */
function addToIgnoreFile(paths: string[]): void {
  const existing = loadIgnorePatterns();
  const newPaths = paths.filter((p) => !existing.has(p));

  if (newPaths.length === 0) return;

  const content = newPaths.join('\n') + '\n';

  if (!existsSync(IGNORE_FILE)) {
    appendFileSync(
      IGNORE_FILE,
      `# Artifact Ignore File\n# Files listed here won't be flagged as orphans\n# Generated by project-tracker\n\n${content}`
    );
  } else {
    appendFileSync(IGNORE_FILE, content);
  }
}

/**
 * Delete a file
 */
function deleteFile(relativePath: string): ActionResult {
  const absolutePath = join(PROJECT_ROOT, relativePath);

  if (!existsSync(absolutePath)) {
    return { path: relativePath, success: false, error: 'File not found' };
  }

  try {
    unlinkSync(absolutePath);
    return { path: relativePath, success: true };
  } catch (error) {
    return { path: relativePath, success: false, error: String(error) };
  }
}

/**
 * Archive a file (move to artifacts/archive/)
 */
function archiveFile(relativePath: string): ActionResult {
  const absolutePath = join(PROJECT_ROOT, relativePath);

  if (!existsSync(absolutePath)) {
    return { path: relativePath, success: false, error: 'File not found' };
  }

  try {
    // Create archive directory structure
    const timestamp = new Date().toISOString().split('T')[0];
    const archiveSubdir = join(ARCHIVE_DIR, timestamp, dirname(relativePath));
    mkdirSync(archiveSubdir, { recursive: true });

    const newPath = join(archiveSubdir, basename(relativePath));
    renameSync(absolutePath, newPath);

    // Return relative path for display
    const relativeNewPath = newPath.replace(PROJECT_ROOT, '').replace(/^[\\/]/, '');
    return { path: relativePath, success: true, newPath: relativeNewPath };
  } catch (error) {
    return { path: relativePath, success: false, error: String(error) };
  }
}

export async function POST(request: NextRequest) {
  try {
    const body: ActionRequest = await request.json();
    const { action, paths } = body;

    if (!action || !paths || !Array.isArray(paths) || paths.length === 0) {
      return NextResponse.json(
        { error: 'Invalid request: action and paths[] required' },
        { status: 400 }
      );
    }

    // Security: Don't allow actions on critical files
    const protectedPatterns = [
      /^\.git\//,
      /^node_modules\//,
      /package\.json$/,
      /^apps\/.*\/src\//,
      /^packages\/.*\/src\//,
      /^CLAUDE\.md$/,
      /^README\.md$/,
    ];

    const unsafePaths = paths.filter((p) =>
      protectedPatterns.some((pattern) => pattern.test(p))
    );

    if (unsafePaths.length > 0) {
      return NextResponse.json(
        { error: `Cannot modify protected files: ${unsafePaths.join(', ')}` },
        { status: 403 }
      );
    }

    let results: ActionResult[] = [];

    switch (action) {
      case 'delete':
        results = paths.map(deleteFile);
        break;

      case 'archive':
        // Ensure archive directory exists
        mkdirSync(ARCHIVE_DIR, { recursive: true });
        results = paths.map(archiveFile);
        break;

      case 'ignore':
        addToIgnoreFile(paths);
        results = paths.map((p) => ({ path: p, success: true }));
        break;

      default:
        return NextResponse.json({ error: `Unknown action: ${action}` }, { status: 400 });
    }

    const successCount = results.filter((r) => r.success).length;
    const failCount = results.filter((r) => !r.success).length;

    return NextResponse.json({
      action,
      total: paths.length,
      success: successCount,
      failed: failCount,
      results,
    });
  } catch (error) {
    console.error('Action error:', error);
    return NextResponse.json(
      { error: 'Failed to execute action', details: String(error) },
      { status: 500 }
    );
  }
}
