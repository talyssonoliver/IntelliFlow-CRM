/**
 * AI ROI (Return on Investment) Tracker
 * Tracks costs, value generated, and calculates ROI metrics for AI operations.
 * Enables data-driven decisions on AI investment.
 *
 * @module roi-tracker
 * @task IFC-117
 */

import pino from 'pino';

const logger = pino({
  name: 'roi-tracker',
  level: process.env.LOG_LEVEL || 'info',
});

/**
 * Types of value generated by AI operations
 */
export type ValueType =
  | 'lead_scored' // Lead scoring automation
  | 'lead_qualified' // Lead qualification
  | 'email_generated' // Email content generation
  | 'response_automated' // Automated customer response
  | 'insight_generated' // Business insight extraction
  | 'document_processed' // Document analysis
  | 'task_automated' // Task automation
  | 'prediction_made' // Predictive analytics
  | 'recommendation_made' // Recommendation engine
  // IFC-024: Human-in-the-Loop Feedback values
  | 'feedback_positive' // User confirms score accuracy
  | 'feedback_negative' // User reports score inaccuracy
  | 'feedback_correction'; // User provides corrected score (training data)

/**
 * Cost entry for AI operation
 */
export interface AICost {
  id: string;
  timestamp: Date;
  model: string;
  operationType: string;
  inputTokens: number;
  outputTokens: number;
  cost: number; // USD
  metadata?: Record<string, unknown>;
}

/**
 * Value entry for AI-generated outcome
 */
export interface AIValue {
  id: string;
  timestamp: Date;
  valueType: ValueType;
  estimatedValue: number; // USD
  confidence: number; // 0-1
  relatedCostIds: string[];
  metadata?: Record<string, unknown>;
}

/**
 * ROI calculation result
 */
export interface ROIResult {
  periodStart: Date;
  periodEnd: Date;
  totalCost: number;
  totalValue: number;
  netValue: number;
  roi: number; // Percentage
  costBreakdown: {
    byModel: Record<string, number>;
    byOperation: Record<string, number>;
  };
  valueBreakdown: Record<ValueType, number>;
  efficiency: number; // Value per dollar spent
  trendDirection: 'improving' | 'stable' | 'declining';
  recommendations: string[];
}

/**
 * Configuration for ROI tracking
 */
export interface ROITrackerConfig {
  valueEstimates: Record<ValueType, number>; // Default USD values
  costPerToken: Record<string, { input: number; output: number }>; // Model token costs
  minROITarget: number; // Minimum acceptable ROI (e.g., 2.0 = 200%)
  trackingPeriodDays: number;
}

/**
 * ROI summary statistics
 */
export interface ROIStats {
  totalCostsTracked: number;
  totalValuesTracked: number;
  currentROI: number;
  averageCostPerOperation: number;
  averageValuePerOperation: number;
  roiTrend: number[]; // Last 7 days
  topPerformingOperations: Array<{ operation: string; roi: number }>;
  underperformingOperations: Array<{ operation: string; roi: number }>;
}

/**
 * ROI Tracker Service
 * Comprehensive tracking of AI costs vs value generated
 */
export class ROITracker {
  private costs: AICost[] = [];
  private values: AIValue[] = [];
  private dailySnapshots: Map<string, ROIResult> = new Map();

  constructor(private readonly config: ROITrackerConfig) {
    logger.info({ config }, 'ROITracker initialized');
  }

  /**
   * Record an AI operation cost
   */
  recordCost(cost: Omit<AICost, 'timestamp'>): AICost {
    const entry: AICost = {
      ...cost,
      timestamp: new Date(),
    };

    this.costs.push(entry);

    logger.debug(
      {
        id: cost.id,
        model: cost.model,
        cost: cost.cost.toFixed(4),
        operation: cost.operationType,
      },
      'AI cost recorded'
    );

    return entry;
  }

  /**
   * Record value generated by AI operation
   */
  recordValue(value: Omit<AIValue, 'timestamp'>): AIValue {
    const entry: AIValue = {
      ...value,
      timestamp: new Date(),
    };

    this.values.push(entry);

    logger.info(
      {
        id: value.id,
        type: value.valueType,
        value: value.estimatedValue.toFixed(2),
        confidence: value.confidence.toFixed(2),
      },
      'AI value recorded'
    );

    return entry;
  }

  /**
   * Auto-record cost from token usage
   */
  recordTokenUsage(params: {
    id: string;
    model: string;
    operationType: string;
    inputTokens: number;
    outputTokens: number;
    metadata?: Record<string, unknown>;
  }): AICost {
    const modelCosts = this.config.costPerToken[params.model] || {
      input: 0.00001,
      output: 0.00003,
    };

    const cost =
      (params.inputTokens * modelCosts.input) +
      (params.outputTokens * modelCosts.output);

    return this.recordCost({
      id: params.id,
      model: params.model,
      operationType: params.operationType,
      inputTokens: params.inputTokens,
      outputTokens: params.outputTokens,
      cost,
      metadata: params.metadata,
    });
  }

  /**
   * Auto-record value with default estimates
   */
  recordValueByType(params: {
    id: string;
    valueType: ValueType;
    relatedCostIds: string[];
    confidenceMultiplier?: number;
    metadata?: Record<string, unknown>;
  }): AIValue {
    const baseValue = this.config.valueEstimates[params.valueType] || 0;
    const confidence = params.confidenceMultiplier ?? 1.0;

    return this.recordValue({
      id: params.id,
      valueType: params.valueType,
      estimatedValue: baseValue * confidence,
      confidence,
      relatedCostIds: params.relatedCostIds,
      metadata: params.metadata,
    });
  }

  /**
   * Calculate ROI for a period
   */
  calculateROI(startTime?: Date, endTime?: Date): ROIResult {
    const start = startTime ?? new Date(Date.now() - this.config.trackingPeriodDays * 24 * 60 * 60 * 1000);
    const end = endTime ?? new Date();

    // Filter data by period
    const periodCosts = this.costs.filter(
      c => c.timestamp >= start && c.timestamp <= end
    );
    const periodValues = this.values.filter(
      v => v.timestamp >= start && v.timestamp <= end
    );

    // Calculate totals
    const totalCost = periodCosts.reduce((sum, c) => sum + c.cost, 0);
    const totalValue = periodValues.reduce((sum, v) => sum + v.estimatedValue, 0);
    const netValue = totalValue - totalCost;
    const roi = totalCost > 0 ? (netValue / totalCost) * 100 : 0;

    // Cost breakdown by model
    const costByModel: Record<string, number> = {};
    for (const cost of periodCosts) {
      costByModel[cost.model] = (costByModel[cost.model] || 0) + cost.cost;
    }

    // Cost breakdown by operation
    const costByOperation: Record<string, number> = {};
    for (const cost of periodCosts) {
      costByOperation[cost.operationType] =
        (costByOperation[cost.operationType] || 0) + cost.cost;
    }

    // Value breakdown by type
    const valueBreakdown: Record<string, number> = {};
    for (const value of periodValues) {
      valueBreakdown[value.valueType] =
        (valueBreakdown[value.valueType] || 0) + value.estimatedValue;
    }

    // Calculate efficiency
    const efficiency = totalCost > 0 ? totalValue / totalCost : 0;

    // Determine trend
    const previousPeriod = this.calculatePreviousPeriodROI(start, end);
    const trendDirection = this.determineTrend(roi, previousPeriod);

    // Generate recommendations
    const recommendations = this.generateRecommendations(
      roi,
      costByModel,
      costByOperation,
      valueBreakdown
    );

    const result: ROIResult = {
      periodStart: start,
      periodEnd: end,
      totalCost,
      totalValue,
      netValue,
      roi,
      costBreakdown: {
        byModel: costByModel,
        byOperation: costByOperation,
      },
      valueBreakdown: valueBreakdown as Record<ValueType, number>,
      efficiency,
      trendDirection,
      recommendations,
    };

    // Store daily snapshot
    const dateKey = end.toISOString().split('T')[0];
    this.dailySnapshots.set(dateKey, result);

    logger.info(
      {
        periodStart: start.toISOString(),
        periodEnd: end.toISOString(),
        totalCost: totalCost.toFixed(2),
        totalValue: totalValue.toFixed(2),
        roi: roi.toFixed(1),
        trend: trendDirection,
      },
      'ROI calculated'
    );

    return result;
  }

  /**
   * Get ROI statistics
   */
  getStats(): ROIStats {
    const now = new Date();
    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

    const currentROI = this.calculateROI(weekAgo, now);

    // Calculate ROI trend (last 7 days)
    const roiTrend: number[] = [];
    for (let i = 6; i >= 0; i--) {
      const dayEnd = new Date(now.getTime() - i * 24 * 60 * 60 * 1000);
      const dayStart = new Date(dayEnd.getTime() - 24 * 60 * 60 * 1000);
      const dayROI = this.calculateROI(dayStart, dayEnd);
      roiTrend.push(dayROI.roi);
    }

    // Find top performing operations
    const operationROIs = this.calculateOperationROIs();
    const sortedOps = Object.entries(operationROIs).sort((a, b) => b[1] - a[1]);
    const topPerforming = sortedOps.slice(0, 5).map(([op, roi]) => ({
      operation: op,
      roi,
    }));
    const underperforming = sortedOps
      .filter(([_, roi]) => roi < 0)
      .map(([op, roi]) => ({ operation: op, roi }));

    return {
      totalCostsTracked: this.costs.length,
      totalValuesTracked: this.values.length,
      currentROI: currentROI.roi,
      averageCostPerOperation: this.costs.length > 0
        ? this.costs.reduce((sum, c) => sum + c.cost, 0) / this.costs.length
        : 0,
      averageValuePerOperation: this.values.length > 0
        ? this.values.reduce((sum, v) => sum + v.estimatedValue, 0) / this.values.length
        : 0,
      roiTrend,
      topPerformingOperations: topPerforming,
      underperformingOperations: underperforming,
    };
  }

  /**
   * Get cost breakdown for current period
   */
  getCostBreakdown(): {
    total: number;
    byModel: Record<string, number>;
    byOperation: Record<string, number>;
    byDay: Record<string, number>;
  } {
    const now = new Date();
    const periodStart = new Date(now.getTime() - this.config.trackingPeriodDays * 24 * 60 * 60 * 1000);

    const periodCosts = this.costs.filter(c => c.timestamp >= periodStart);

    const byModel: Record<string, number> = {};
    const byOperation: Record<string, number> = {};
    const byDay: Record<string, number> = {};

    for (const cost of periodCosts) {
      byModel[cost.model] = (byModel[cost.model] || 0) + cost.cost;
      byOperation[cost.operationType] = (byOperation[cost.operationType] || 0) + cost.cost;

      const dateKey = cost.timestamp.toISOString().split('T')[0];
      byDay[dateKey] = (byDay[dateKey] || 0) + cost.cost;
    }

    return {
      total: periodCosts.reduce((sum, c) => sum + c.cost, 0),
      byModel,
      byOperation,
      byDay,
    };
  }

  /**
   * Get value breakdown for current period
   */
  getValueBreakdown(): {
    total: number;
    byType: Record<ValueType, number>;
    byDay: Record<string, number>;
    averageConfidence: number;
  } {
    const now = new Date();
    const periodStart = new Date(now.getTime() - this.config.trackingPeriodDays * 24 * 60 * 60 * 1000);

    const periodValues = this.values.filter(v => v.timestamp >= periodStart);

    const byType: Record<string, number> = {};
    const byDay: Record<string, number> = {};

    for (const value of periodValues) {
      byType[value.valueType] = (byType[value.valueType] || 0) + value.estimatedValue;

      const dateKey = value.timestamp.toISOString().split('T')[0];
      byDay[dateKey] = (byDay[dateKey] || 0) + value.estimatedValue;
    }

    const avgConfidence = periodValues.length > 0
      ? periodValues.reduce((sum, v) => sum + v.confidence, 0) / periodValues.length
      : 0;

    return {
      total: periodValues.reduce((sum, v) => sum + v.estimatedValue, 0),
      byType: byType as Record<ValueType, number>,
      byDay,
      averageConfidence: avgConfidence,
    };
  }

  /**
   * Export ROI report
   */
  exportReport(): string {
    const stats = this.getStats();
    const currentROI = this.calculateROI();
    const costBreakdown = this.getCostBreakdown();
    const valueBreakdown = this.getValueBreakdown();

    let report = '=== AI ROI Report ===\n\n';
    report += `Period: ${currentROI.periodStart.toISOString()} to ${currentROI.periodEnd.toISOString()}\n\n`;

    report += '--- Summary ---\n';
    report += `Total Cost: $${currentROI.totalCost.toFixed(2)}\n`;
    report += `Total Value: $${currentROI.totalValue.toFixed(2)}\n`;
    report += `Net Value: $${currentROI.netValue.toFixed(2)}\n`;
    report += `ROI: ${currentROI.roi.toFixed(1)}%\n`;
    report += `Trend: ${currentROI.trendDirection}\n`;
    report += `Target ROI: ${this.config.minROITarget * 100}%\n`;
    report += `Status: ${currentROI.roi >= this.config.minROITarget * 100 ? 'ON TARGET' : 'BELOW TARGET'}\n\n`;

    report += '--- Cost Breakdown by Model ---\n';
    for (const [model, cost] of Object.entries(costBreakdown.byModel)) {
      report += `  ${model}: $${cost.toFixed(4)}\n`;
    }

    report += '\n--- Cost Breakdown by Operation ---\n';
    for (const [op, cost] of Object.entries(costBreakdown.byOperation)) {
      report += `  ${op}: $${cost.toFixed(4)}\n`;
    }

    report += '\n--- Value Breakdown by Type ---\n';
    for (const [type, value] of Object.entries(valueBreakdown.byType)) {
      report += `  ${type}: $${value.toFixed(2)}\n`;
    }

    report += '\n--- Top Performing Operations ---\n';
    for (const { operation, roi } of stats.topPerformingOperations) {
      report += `  ${operation}: ${roi.toFixed(1)}% ROI\n`;
    }

    if (stats.underperformingOperations.length > 0) {
      report += '\n--- Underperforming Operations ---\n';
      for (const { operation, roi } of stats.underperformingOperations) {
        report += `  ${operation}: ${roi.toFixed(1)}% ROI\n`;
      }
    }

    report += '\n--- Recommendations ---\n';
    for (const rec of currentROI.recommendations) {
      report += `  - ${rec}\n`;
    }

    return report;
  }

  /**
   * Calculate ROI for previous period (for trend comparison)
   */
  private calculatePreviousPeriodROI(currentStart: Date, currentEnd: Date): number {
    const periodLength = currentEnd.getTime() - currentStart.getTime();
    const prevEnd = new Date(currentStart.getTime());
    const prevStart = new Date(currentStart.getTime() - periodLength);

    const prevResult = this.calculateROI(prevStart, prevEnd);
    return prevResult.roi;
  }

  /**
   * Determine ROI trend direction
   */
  private determineTrend(
    currentROI: number,
    previousROI: number
  ): 'improving' | 'stable' | 'declining' {
    const change = currentROI - previousROI;
    if (change > 5) return 'improving';
    if (change < -5) return 'declining';
    return 'stable';
  }

  /**
   * Calculate ROI per operation type
   */
  private calculateOperationROIs(): Record<string, number> {
    const operationData: Record<string, { cost: number; value: number }> = {};

    // Aggregate costs by operation
    for (const cost of this.costs) {
      if (!operationData[cost.operationType]) {
        operationData[cost.operationType] = { cost: 0, value: 0 };
      }
      operationData[cost.operationType].cost += cost.cost;
    }

    // Map values to operations via related costs
    for (const value of this.values) {
      for (const costId of value.relatedCostIds) {
        const relatedCost = this.costs.find(c => c.id === costId);
        if (relatedCost) {
          if (!operationData[relatedCost.operationType]) {
            operationData[relatedCost.operationType] = { cost: 0, value: 0 };
          }
          operationData[relatedCost.operationType].value += value.estimatedValue;
        }
      }
    }

    // Calculate ROI per operation
    const rois: Record<string, number> = {};
    for (const [op, data] of Object.entries(operationData)) {
      rois[op] = data.cost > 0 ? ((data.value - data.cost) / data.cost) * 100 : 0;
    }

    return rois;
  }

  /**
   * Generate actionable recommendations
   */
  private generateRecommendations(
    roi: number,
    costByModel: Record<string, number>,
    costByOperation: Record<string, number>,
    valueBreakdown: Record<string, number>
  ): string[] {
    const recommendations: string[] = [];
    const targetROI = this.config.minROITarget * 100;

    // ROI below target
    if (roi < targetROI) {
      recommendations.push(
        `ROI is ${(targetROI - roi).toFixed(1)}% below target. Review high-cost operations.`
      );
    }

    // Find highest cost model
    const modelEntries = Object.entries(costByModel).sort((a, b) => b[1] - a[1]);
    if (modelEntries.length > 0 && modelEntries[0][1] > 0.1) {
      recommendations.push(
        `Consider using cheaper model alternatives for '${modelEntries[0][0]}' operations.`
      );
    }

    // Find operations with no recorded value
    const opCosts = new Set(Object.keys(costByOperation));
    const opValues = new Set(
      this.values.flatMap(v =>
        v.relatedCostIds.map(id => this.costs.find(c => c.id === id)?.operationType)
      ).filter(Boolean)
    );

    for (const op of opCosts) {
      if (!opValues.has(op)) {
        recommendations.push(
          `Operation '${op}' has costs but no recorded value. Review or add value tracking.`
        );
      }
    }

    // Find high-value operations
    const valueEntries = Object.entries(valueBreakdown).sort((a, b) => b[1] - a[1]);
    if (valueEntries.length > 0) {
      recommendations.push(
        `'${valueEntries[0][0]}' generates most value ($${valueEntries[0][1].toFixed(2)}). Consider expanding.`
      );
    }

    // General recommendations
    if (this.costs.length < 10) {
      recommendations.push('Limited data available. Continue tracking for better insights.');
    }

    return recommendations;
  }

  /**
   * Prune old data (retention policy)
   */
  pruneOldData(maxAgeDays: number = 90): { costsRemoved: number; valuesRemoved: number } {
    const cutoff = new Date(Date.now() - maxAgeDays * 24 * 60 * 60 * 1000);

    const originalCosts = this.costs.length;
    const originalValues = this.values.length;

    this.costs = this.costs.filter(c => c.timestamp > cutoff);
    this.values = this.values.filter(v => v.timestamp > cutoff);

    return {
      costsRemoved: originalCosts - this.costs.length,
      valuesRemoved: originalValues - this.values.length,
    };
  }
}

/**
 * Default ROI tracker configuration
 */
export const defaultROIConfig: ROITrackerConfig = {
  valueEstimates: {
    lead_scored: 0.50, // Value of automated lead scoring
    lead_qualified: 2.00, // Value of lead qualification
    email_generated: 1.00, // Value of email generation
    response_automated: 1.50, // Value of automated response
    insight_generated: 3.00, // Value of business insight
    document_processed: 0.75, // Value of document analysis
    task_automated: 2.50, // Value of task automation
    prediction_made: 5.00, // Value of prediction
    recommendation_made: 4.00, // Value of recommendation
    // IFC-024: Human-in-the-Loop Feedback values
    feedback_positive: 0.10, // Confirmation of score accuracy
    feedback_negative: -0.20, // Error signal (negative value - cost of poor scoring)
    feedback_correction: 0.50, // Training data for model improvement
  },
  costPerToken: {
    'gpt-4': { input: 0.00003, output: 0.00006 },
    'gpt-4-turbo': { input: 0.00001, output: 0.00003 },
    'gpt-3.5-turbo': { input: 0.0000005, output: 0.0000015 },
    'claude-3-opus': { input: 0.000015, output: 0.000075 },
    'claude-3-sonnet': { input: 0.000003, output: 0.000015 },
    'claude-3-haiku': { input: 0.00000025, output: 0.00000125 },
    'llama-3': { input: 0, output: 0 }, // Local model
    'mistral': { input: 0, output: 0 }, // Local model
  },
  minROITarget: 2.0, // 200% ROI target
  trackingPeriodDays: 30,
};

/**
 * Global ROI tracker instance
 */
export const roiTracker = new ROITracker(defaultROIConfig);

/**
 * Prometheus metrics format for ROI tracking
 */
export function getROIMetrics(): string {
  const stats = roiTracker.getStats();
  const costBreakdown = roiTracker.getCostBreakdown();
  const valueBreakdown = roiTracker.getValueBreakdown();

  let metrics = '';

  metrics += `# HELP intelliflow_ai_roi_current Current ROI percentage\n`;
  metrics += `# TYPE intelliflow_ai_roi_current gauge\n`;
  metrics += `intelliflow_ai_roi_current ${stats.currentROI.toFixed(2)}\n`;

  metrics += `# HELP intelliflow_ai_total_cost Total AI costs in USD\n`;
  metrics += `# TYPE intelliflow_ai_total_cost gauge\n`;
  metrics += `intelliflow_ai_total_cost ${costBreakdown.total.toFixed(4)}\n`;

  metrics += `# HELP intelliflow_ai_total_value Total AI value generated in USD\n`;
  metrics += `# TYPE intelliflow_ai_total_value gauge\n`;
  metrics += `intelliflow_ai_total_value ${valueBreakdown.total.toFixed(2)}\n`;

  metrics += `# HELP intelliflow_ai_cost_by_model AI cost by model in USD\n`;
  metrics += `# TYPE intelliflow_ai_cost_by_model gauge\n`;
  for (const [model, cost] of Object.entries(costBreakdown.byModel)) {
    metrics += `intelliflow_ai_cost_by_model{model="${model}"} ${cost.toFixed(4)}\n`;
  }

  metrics += `# HELP intelliflow_ai_value_by_type AI value by type in USD\n`;
  metrics += `# TYPE intelliflow_ai_value_by_type gauge\n`;
  for (const [type, value] of Object.entries(valueBreakdown.byType)) {
    metrics += `intelliflow_ai_value_by_type{type="${type}"} ${value.toFixed(2)}\n`;
  }

  metrics += `# HELP intelliflow_ai_operations_total Total AI operations tracked\n`;
  metrics += `# TYPE intelliflow_ai_operations_total counter\n`;
  metrics += `intelliflow_ai_operations_total{type="cost"} ${stats.totalCostsTracked}\n`;
  metrics += `intelliflow_ai_operations_total{type="value"} ${stats.totalValuesTracked}\n`;

  return metrics;
}
